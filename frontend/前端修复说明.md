# 前端修复说明 - 模板删除后文档仍可编辑

## 📋 问题描述

当模板被删除后，`template_id` 被数据库自动设置为 `NULL`（通过 `ondelete='SET NULL'` 外键约束）。

**原有前端逻辑的问题**：
- 前端在 `WPSEdit.tsx`、`PQREdit.tsx`、`PPQREdit.tsx` 中检查 `template` 是否存在
- 如果 `template` 不存在，显示警告："此文档不是使用模板创建的，无法使用模板编辑器编辑"
- **完全阻止了编辑功能**

**实际情况**：
- 文档数据完整保存在 `modules_data` 字段中
- 即使模板被删除，文档数据仍然完整
- 应该可以直接从 `modules_data` 渲染表单进行编辑

---

## ✅ 修复内容

### 修改的文件

1. `frontend/src/pages/WPS/WPSEdit.tsx`
2. `frontend/src/pages/PQR/PQREdit.tsx`
3. `frontend/src/pages/pPQR/PPQREdit.tsx`

### 修复逻辑

#### 1. 获取模板时不显示错误

**修改前**：
```typescript
if (wps.template_id) {
  try {
    const templateResponse = await wpsTemplateService.getTemplate(wps.template_id)
    if (templateResponse.success && templateResponse.data) {
      setTemplate(templateResponse.data)
    }
  } catch (error) {
    console.error('获取模板失败:', error)
  }
}
```

**修改后**：
```typescript
if (wps.template_id) {
  try {
    const templateResponse = await wpsTemplateService.getTemplate(wps.template_id)
    if (templateResponse.success && templateResponse.data) {
      setTemplate(templateResponse.data)
    }
  } catch (error) {
    console.warn('获取模板失败（模板可能已被删除）:', error)
    // 模板不存在时不显示错误，因为文档数据仍然完整
  }
}
```

#### 2. 从 modules_data 恢复表单值

**修改**：即使没有模板，也从 `modules_data` 中恢复表单值

```typescript
// 从 modules_data 中恢复表单值
if (ppqr.modules_data) {
  Object.entries(ppqr.modules_data).forEach(([instanceId, moduleContent]: [string, any]) => {
    if (moduleContent && moduleContent.data) {
      // 如果有模板，找到对应的模块实例
      const moduleInstance = templateData?.module_instances?.find(
        (inst: any) => inst.instanceId === instanceId
      )

      Object.entries(moduleContent.data).forEach(([fieldKey, fieldValue]: [string, any]) => {
        const formFieldName = `${instanceId}_${fieldKey}`

        // 获取字段定义（优先使用模板，否则使用 moduleContent.moduleId）
        const module = moduleInstance 
          ? getPPQRModuleById(moduleInstance.moduleId)
          : getPPQRModuleById(moduleContent.moduleId)
        const fieldDef = module?.fields?.[fieldKey]

        // 处理日期字段等...
        formValues[formFieldName] = fieldValue
      })
    }
  })
}
```

#### 3. 保存时支持无模板情况

**修改前**：只在有模板时重新构建 `modules_data`

**修改后**：
```typescript
// 如果有模板，使用模板结构
if (template && template.module_instances) {
  // 使用模板结构构建 modules_data
  template.module_instances.forEach(instance => {
    // ...
  })
} else if (wpsData?.modules_data) {
  // 没有模板时，保留原有的 modules_data 结构，只更新表单值
  Object.entries(wpsData.modules_data).forEach(([instanceId, moduleContent]: [string, any]) => {
    if (moduleContent && moduleContent.data) {
      const moduleData: Record<string, any> = {}
      const module = getModuleById(moduleContent.moduleId)

      if (module) {
        Object.keys(module.fields).forEach(fieldKey => {
          const formFieldName = `${instanceId}_${fieldKey}`
          if (values[formFieldName] !== undefined) {
            // 处理日期字段等...
            moduleData[fieldKey] = fieldValue
          }
        })
      }

      if (Object.keys(moduleData).length > 0) {
        modulesData[instanceId] = {
          moduleId: moduleContent.moduleId,
          customName: moduleContent.customName,
          data: moduleData,
        }
      }
    }
  })
}
```

#### 4. UI 显示逻辑

**修改前**：
```typescript
{template ? (
  // 显示编辑表单
) : (
  <Alert
    message="此WPS不是使用模板创建的"
    description="无法使用模板编辑器编辑此WPS"
    type="warning"
    showIcon
  />
)}
```

**修改后**：
```typescript
{/* 如果模板被删除，显示警告信息 */}
{!template && wpsData?.modules_data && (
  <Alert
    message="模板已被删除"
    description="此文档使用的模板已被删除，但文档数据完整，仍可正常编辑。"
    type="warning"
    showIcon
    closable
    style={{ marginBottom: 16 }}
  />
)}

{/* 如果有模板，显示模板信息 */}
{template && (
  <Alert
    message="使用模板编辑"
    description={`当前使用模板: ${template.name || template.id}`}
    type="info"
    showIcon
    closable
    style={{ marginBottom: 16 }}
  />
)}

{/* 如果有 modules_data（无论是否有模板），都可以编辑 */}
{wpsData?.modules_data ? (
  <>
    <Form form={form} layout="vertical">
      {/* 模块表单 - 使用模板或从 modules_data 重建 */}
      {template && template.module_instances ? (
        <ModuleFormRenderer
          modules={template.module_instances || []}
          form={form}
        />
      ) : (
        <ModuleFormRenderer
          modules={Object.entries(wpsData.modules_data).map(([instanceId, content]: [string, any]) => ({
            instanceId,
            moduleId: content.moduleId,
            customName: content.customName || '',
          }))}
          form={form}
        />
      )}
    </Form>

    <Space style={{ marginTop: 24 }}>
      <Button type="primary" icon={<SaveOutlined />} loading={saving} onClick={handleSave}>
        保存
      </Button>
      <Button onClick={() => navigate('/wps')}>取消</Button>
    </Space>
  </>
) : (
  <Alert
    message="无法编辑此WPS"
    description="此WPS没有模块数据，无法编辑"
    type="error"
    showIcon
  />
)}
```

---

## 🎯 修复效果

### 场景：模板被删除后编辑文档

**修复前**：
1. 用户创建 WPS/PQR/pPQR 文档
2. 管理员删除模板
3. 用户尝试编辑文档
4. ❌ 显示"无法使用模板编辑器编辑此文档"
5. ❌ 完全无法编辑

**修复后**：
1. 用户创建 WPS/PQR/pPQR 文档
2. 管理员删除模板
3. 用户尝试编辑文档
4. ✅ 显示警告："模板已被删除，但文档数据完整，仍可正常编辑"
5. ✅ 可以正常编辑和保存文档
6. ✅ 文档数据从 `modules_data` 中加载
7. ✅ 保存时更新 `modules_data`

---

## 📊 技术细节

### 数据流

1. **加载文档**：
   - 从后端获取文档数据（包括 `template_id` 和 `modules_data`）
   - 如果 `template_id` 存在，尝试获取模板（可能失败）
   - 从 `modules_data` 恢复表单值（无论是否有模板）

2. **渲染表单**：
   - 如果有模板：使用 `template.module_instances` 渲染表单
   - 如果没有模板：从 `modules_data` 重建模块实例列表渲染表单

3. **保存文档**：
   - 如果有模板：使用模板结构构建 `modules_data`
   - 如果没有模板：保留原有 `modules_data` 结构，只更新字段值

### 关键点

1. **数据独立性**：文档数据保存在 `modules_data` 中，不依赖模板
2. **向后兼容**：有模板时仍然使用模板结构
3. **用户体验**：清晰的提示信息，告知用户模板已删除但仍可编辑
4. **数据完整性**：保存时保留原有的模块结构和自定义名称

---

## ✅ 测试建议

### 测试场景

1. **有模板的文档编辑**：
   - 创建文档
   - 编辑文档
   - 验证可以正常保存

2. **模板被删除后的文档编辑**：
   - 创建文档
   - 删除模板
   - 编辑文档
   - 验证显示警告信息
   - 验证可以正常编辑和保存
   - 验证数据完整性

3. **日期字段处理**：
   - 验证日期字段在加载时正确转换为 dayjs 对象
   - 验证日期字段在保存时正确转换为字符串

---

## 🎉 总结

前端修复完成！现在：

1. ✅ 模板删除后，文档仍然可以编辑
2. ✅ 显示清晰的警告信息
3. ✅ 数据从 `modules_data` 加载和保存
4. ✅ 保持向后兼容性
5. ✅ 用户体验良好

配合后端的外键修复（`ondelete='SET NULL'`），完整实现了：
- 共享库模块独立性
- 文档编辑独立性

