# 模板画布智能分列功能说明

## 功能概述

实现了智能的拖拽分列逻辑:
- ✅ **拖拽时显示放置区域**: 从模块库拖拽时,自动显示左、中、右放置区域
- ✅ **自动平分列宽**: 当在一行中添加更多模块时,自动平均分配列宽
- ✅ **自动扩展**: 当删除模块时,剩余模块自动变宽以填充空间
- ✅ **拖拽排序**: 保留原有的拖拽排序功能
- ✅ **直观的视觉反馈**: 拖拽时高亮显示可放置区域

## 核心逻辑

### 1. 数据结构

每个模块实例包含:
```typescript
interface ModuleInstance {
  instanceId: string   // 实例唯一ID
  moduleId: string     // 模块定义ID
  order: number        // 排序
  customName?: string  // 自定义名称
  rowIndex?: number    // 所在行索引 (新增)
  columnIndex?: number // 所在列索引 (新增)
}
```

### 2. 自动分列算法

**列宽计算公式**:
```typescript
const columnsInRow = row.length  // 该行的列数
const columnSpan = Math.floor(24 / columnsInRow)  // 每列的宽度
```

**示例**:
- 1个模块: `24 / 1 = 24` (全宽)
- 2个模块: `24 / 2 = 12` (各占一半)
- 3个模块: `24 / 3 = 8` (各占三分之一)
- 4个模块: `24 / 4 = 6` (各占四分之一)

### 3. 添加列的逻辑

当用户点击左侧或右侧添加按钮时:
1. 检查该行是否已达到最大列数(4列)
2. 创建一个占位符模块
3. 更新该行其他模块的列索引
4. 自动重新计算列宽

### 4. 删除模块的逻辑

当用户删除模块时:
1. 从模块列表中移除该模块
2. 重新计算该行剩余模块的列索引
3. 自动重新计算列宽(剩余模块自动变宽)

## 使用方法

### 1. 添加模块到新行
1. 从左侧模块库拖拽模块
2. 拖到画布底部会显示蓝色虚线框 "↓ 放置到新行"
3. 释放鼠标,模块添加到新行(全宽显示)

### 2. 添加模块到现有行的左侧
1. 从左侧模块库拖拽模块
2. 拖到任意模块的**左侧**,会显示蓝色虚线框 "← 放置到左侧"
3. 释放鼠标,模块添加到该行左侧
4. 该行所有模块自动平分列宽

### 3. 添加模块到现有行的右侧
1. 从左侧模块库拖拽模块
2. 拖到任意模块的**右侧**,会显示蓝色虚线框 "放置到右侧 →"
3. 释放鼠标,模块添加到该行右侧
4. 该行所有模块自动平分列宽

### 4. 删除模块
- 点击模块右上角的删除按钮
- 该行的其他模块会自动变宽填充空间

### 5. 拖拽排序
- 点击拖拽图标 ⋮⋮
- 拖动到目标位置
- 释放鼠标完成排序

## 布局示例

### 示例 1: 单列布局
```
┌───────────────────────────────────────────┐
│          基本信息 (1列 = 全宽)            │
└───────────────────────────────────────────┘
┌───────────────────────────────────────────┐
│          填充金属 (1列 = 全宽)            │
└───────────────────────────────────────────┘
```

### 示例 2: 两列布局
```
┌─────────────────────┬─────────────────────┐
│   基材信息 (2列)    │   填充材料 (2列)    │
│   每列宽度: 12      │   每列宽度: 12      │
└─────────────────────┴─────────────────────┘
```

### 示例 3: 三列布局
```
┌──────────────┬──────────────┬──────────────┐
│  第1层 (3列) │  第2层 (3列) │  第3层 (3列) │
│  宽度: 8     │  宽度: 8     │  宽度: 8     │
└──────────────┴──────────────┴──────────────┘
```

### 示例 4: 四列布局
```
┌──────────┬──────────┬──────────┬──────────┐
│ 电流(4列)│ 电压(4列)│ 速度(4列)│ 热输入   │
│ 宽度: 6  │ 宽度: 6  │ 宽度: 6  │ 宽度: 6  │
└──────────┴──────────┴──────────┴──────────┘
```

### 示例 5: 混合布局
```
┌───────────────────────────────────────────┐
│          表头信息 (1列 = 全宽)            │
└───────────────────────────────────────────┘
┌─────────────────────┬─────────────────────┐
│   基材信息 (2列)    │   填充材料 (2列)    │
└─────────────────────┴─────────────────────┘
┌──────────────┬──────────────┬──────────────┐
│  第1层 (3列) │  第2层 (3列) │  第3层 (3列) │
└──────────────┴──────────────┴──────────────┘
┌──────────┬──────────┬──────────┬──────────┐
│ 电流(4列)│ 电压(4列)│ 速度(4列)│ 热输入   │
└──────────┴──────────┴──────────┴──────────┘
```

## 限制

- **最大列数**: 每行最多支持4列
- **最小列数**: 每行最少1列
- **列宽自动**: 列宽由系统自动计算,无法手动设置
- **放置区域**: 只有从模块库拖拽时才显示放置区域,画布内拖拽排序不显示

## 技术实现

### 核心组件

1. **TemplateCanvas.tsx**
   - 显示模块画布
   - 处理行列布局
   - 显示拖放区域(DropZone)
   - 自动计算列宽
   - 实时高亮可放置区域

2. **TemplateBuilder.tsx**
   - 管理模块列表
   - 处理拖放逻辑(handleDragEnd, handleDragOver)
   - 处理添加/删除/排序逻辑
   - 维护行列索引
   - 跟踪拖拽状态

3. **TemplatePreview.tsx**
   - 预览模板布局
   - 使用相同的行列逻辑

4. **DropZone组件**
   - 显示可放置区域
   - 提供视觉反馈(虚线边框、背景色)
   - 显示提示文字

### 关键函数

#### groupModulesIntoRows()
将模块按行分组并排序:
```typescript
const groupModulesIntoRows = () => {
  const rowsMap = new Map<number, ModuleInstance[]>()
  
  modules.forEach((module) => {
    const rowIdx = module.rowIndex ?? 0
    if (!rowsMap.has(rowIdx)) {
      rowsMap.set(rowIdx, [])
    }
    rowsMap.get(rowIdx)!.push(module)
  })

  const rows: ModuleInstance[][] = []
  const sortedRowIndices = Array.from(rowsMap.keys()).sort((a, b) => a - b)
  
  sortedRowIndices.forEach((rowIdx) => {
    const rowModules = rowsMap.get(rowIdx)!
    rowModules.sort((a, b) => (a.columnIndex ?? 0) - (b.columnIndex ?? 0))
    rows.push(rowModules)
  })

  return rows
}
```

#### handleDragEnd()
处理拖放结束事件:
```typescript
const handleDragEnd = (event: DragEndEvent) => {
  // 1. 检查是否拖到了放置区(drop-xxx)
  // 2. 根据position(left/center/right)决定添加位置
  // 3. 更新该行其他模块的列索引
  // 4. 添加到模块列表
}
```

#### handleDragOver()
处理拖拽悬停事件:
```typescript
const handleDragOver = (event: any) => {
  // 1. 检查是否悬停在放置区上
  // 2. 更新overDropZone状态
  // 3. 触发DropZone高亮显示
}
```

#### handleRemoveModule()
删除模块并重新计算列索引:
```typescript
const handleRemoveModule = (instanceId: string) => {
  // 1. 找到要删除的模块
  // 2. 从列表中移除
  // 3. 重新计算该行剩余模块的列索引
  // 4. 自动重新计算列宽(通过 columnsInRow 变化)
}
```

## 优势

1. **智能自动**: 无需手动设置列宽,系统自动计算
2. **直观操作**: 拖拽时实时显示可放置区域,所见即所得
3. **灵活布局**: 支持1-4列的任意组合
4. **自动适应**: 添加/删除模块时自动调整列宽
5. **实时预览**: 预览界面完全同步显示布局
6. **视觉反馈**: 蓝色虚线框和提示文字,清晰明了

## 用户体验

- ✅ 拖拽时显示放置区域,更直观
- ✅ 蓝色高亮反馈,更清晰
- ✅ 自动调整列宽,更智能
- ✅ 无需额外点击,一步到位
- ✅ 预览同步更准确

## 后续优化建议

1. 支持跨行拖拽(将模块从一行拖到另一行)
2. 支持列宽微调(在自动计算基础上允许小幅调整)
3. 添加快速布局模板(一键应用常用布局)
4. 支持导出/导入布局配置
5. 添加撤销/重做功能

